"""
Bot Code Generator for Workflow Observer AI

This module uses Claude API to generate complete Python automation scripts
based on detected workflow patterns. It creates production-ready bots with:
- Error handling and logging
- Configuration management
- Multiple automation approaches (RPA, API, file processing)
- Monitoring and notifications

The generator analyzes workflow patterns and creates custom automation code
that can handle the specific applications and data flows detected.
"""

import anthropic
import os
import json
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from dotenv import load_dotenv

load_dotenv()


class BotCodeGenerator:
    """
    Generates complete Python automation scripts from workflow patterns.
    
    This class takes detected workflow patterns and creates production-ready
    automation bots that can replicate the manual workflows automatically.
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize the bot code generator.
        
        Args:
            api_key (str, optional): Anthropic API key
        """
        
        self.api_key = api_key or os.getenv('ANTHROPIC_API_KEY')
        
        if not self.api_key:
            raise ValueError("Anthropic API key is required")
        
        try:
            self.client = anthropic.Anthropic(api_key=self.api_key)
            print("âœ… Bot Code Generator initialized")
        except Exception as e:
            print(f"âŒ Error initializing Claude client: {e}")
            raise
        
        self.generated_bots = {}
        self.total_generations = 0
        
        # Setup output directory
        self.bots_dir = Path("generated_bots")
        self.bots_dir.mkdir(exist_ok=True)
        
        print("ğŸ¤– Bot Code Generator ready!")
    
    def _create_generation_prompt(self, pattern: Dict[str, Any]) -> str:
        """
        Create the prompt for generating automation bot code.
        
        Args:
            pattern: Detected workflow pattern from pattern analysis
            
        Returns:
            str: Complete prompt for Claude API
        """
        
        prompt = f"""You are an expert Python automation developer. Generate a complete, production-ready Python automation script based on this detected workflow pattern.

DETECTED WORKFLOW PATTERN:
{json.dumps(pattern, indent=2)}

REQUIREMENTS:
1. Create a complete Python script that can automate this entire workflow
2. Handle all the applications mentioned in the pattern
3. Include proper error handling, logging, and retry logic
4. Make it configurable through a config.json file
5. Add monitoring and notification capabilities
6. Use appropriate automation techniques:
   - Selenium for web automation
   - pyautogui for desktop automation  
   - API calls where possible
   - File processing for documents
   - Email automation with smtplib/imaplib

SCRIPT STRUCTURE:
```python
#!/usr/bin/env python3
\"\"\"
[Bot Name] - Automated workflow for [Pattern Description]

Generated by Workflow Observer AI
Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

This bot automates: [workflow description]
Applications: [list of apps]
Estimated time savings: [time savings]
\"\"\"

import logging
import json
import time
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

# Import automation libraries
import selenium.webdriver as webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import pyautogui
import requests
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class [BotClassName]:
    \"\"\"
    Automation bot for [workflow description]
    \"\"\"
    
    def __init__(self, config_file: str = "config.json"):
        \"\"\"Initialize the automation bot\"\"\"
        self.config = self._load_config(config_file)
        self._setup_logging()
        self._setup_automation_tools()
        
    def _load_config(self, config_file: str) -> Dict:
        \"\"\"Load configuration from JSON file\"\"\"
        # Implementation here
        
    def _setup_logging(self):
        \"\"\"Setup logging configuration\"\"\"
        # Implementation here
        
    def _setup_automation_tools(self):
        \"\"\"Initialize automation tools (browser, etc.)\"\"\"
        # Implementation here
        
    def run_automation(self) -> Dict[str, Any]:
        \"\"\"
        Main automation workflow
        
        Returns:
            Dict with execution results
        \"\"\"
        # Main automation logic here
        
    def _step_1_[description](self):
        \"\"\"[First workflow step]\"\"\"
        # Implementation here
        
    def _step_2_[description](self):
        \"\"\"[Second workflow step]\"\"\"
        # Implementation here
        
    # Additional workflow steps...
    
    def _send_notification(self, message: str, success: bool = True):
        \"\"\"Send completion notification\"\"\"
        # Implementation here
        
    def cleanup(self):
        \"\"\"Cleanup resources\"\"\"
        # Implementation here

def main():
    \"\"\"Main execution function\"\"\"
    bot = [BotClassName]()
    try:
        result = bot.run_automation()
        print(f"âœ… Automation completed: {{result}}")
    except Exception as e:
        print(f"âŒ Automation failed: {{e}}")
    finally:
        bot.cleanup()

if __name__ == "__main__":
    main()
```

ADDITIONAL REQUIREMENTS:
1. Generate a sample config.json file with all necessary configuration options
2. Include detailed docstrings and comments
3. Add proper exception handling for each step
4. Include retry logic for network operations
5. Add progress logging and status updates
6. Make the script runnable from command line
7. Include installation requirements (pip install commands)

AUTOMATION APPROACH SELECTION:
- For web applications: Use Selenium WebDriver
- For desktop applications: Use pyautogui with image recognition
- For APIs: Use requests library with proper authentication
- For email: Use imaplib/smtplib
- For file processing: Use appropriate libraries (PyPDF2, openpyxl, etc.)

Generate the complete, working Python automation script that can replicate this workflow automatically.
"""
        
        return prompt
    
    def _extract_code_from_response(self, response: str) -> tuple[str, str, str]:
        """
        Extract Python code, config, and requirements from Claude's response.
        
        Returns:
            tuple: (python_code, config_json, requirements_txt)
        """
        
        # Extract Python code
        python_pattern = r'```python\n(.*?)\n```'
        python_matches = re.findall(python_pattern, response, re.DOTALL)
        python_code = python_matches[0] if python_matches else ""
        
        # Extract JSON config
        json_pattern = r'```json\n(.*?)\n```'
        json_matches = re.findall(json_pattern, response, re.DOTALL)
        config_json = json_matches[0] if json_matches else ""
        
        # Extract requirements
        req_pattern = r'```(?:txt|requirements)\n(.*?)\n```'
        req_matches = re.findall(req_pattern, response, re.DOTALL)
        requirements = req_matches[0] if req_matches else ""
        
        # If no code blocks found, try to extract from the full response
        if not python_code:
            # Look for class definitions as a fallback
            class_pattern = r'(class \w+:.*)'
            class_matches = re.findall(class_pattern, response, re.DOTALL)
            if class_matches:
                python_code = class_matches[0]
        
        return python_code, config_json, requirements
    
    def _create_default_config(self, pattern: Dict[str, Any]) -> str:
        """
        Create a default configuration file for the generated bot.
        
        Args:
            pattern: Workflow pattern information
            
        Returns:
            str: JSON configuration template
        """
        
        config = {
            "bot_info": {
                "name": pattern.get("pattern_name", "Automation Bot"),
                "description": pattern.get("business_value", ""),
                "created": datetime.now().isoformat(),
                "applications": pattern.get("applications_involved", [])
            },
            "automation_settings": {
                "retry_attempts": 3,
                "timeout_seconds": 30,
                "delay_between_actions": 1.0,
                "headless_browser": False,
                "screenshot_on_error": True
            },
            "credentials": {
                "email": {
                    "smtp_server": "smtp.gmail.com",
                    "smtp_port": 587,
                    "username": "",
                    "password": "",
                    "recipient": ""
                },
                "web_apps": {
                    "username": "",
                    "password": "",
                    "login_url": ""
                },
                "api_keys": {
                    "quickbooks": "",
                    "salesforce": "",
                    "other": ""
                }
            },
            "file_paths": {
                "input_directory": "./input",
                "output_directory": "./output",
                "log_directory": "./logs",
                "backup_directory": "./backup"
            },
            "notifications": {
                "send_email_notifications": True,
                "send_slack_notifications": False,
                "email_on_success": True,
                "email_on_failure": True,
                "slack_webhook_url": ""
            },
            "scheduling": {
                "run_automatically": False,
                "schedule_type": "daily",
                "schedule_time": "09:00",
                "run_on_weekends": False
            }
        }
        
        return json.dumps(config, indent=2)
    
    def _create_requirements_file(self, pattern: Dict[str, Any]) -> str:
        """
        Create a requirements.txt file based on the workflow pattern.
        
        Args:
            pattern: Workflow pattern information
            
        Returns:
            str: Requirements file content
        """
        
        base_requirements = [
            "selenium>=4.0.0",
            "pyautogui>=0.9.54",
            "requests>=2.28.0",
            "python-dotenv>=0.19.0",
            "pathlib>=1.0.1",
            "Pillow>=9.0.0"
        ]
        
        # Add specific requirements based on applications
        applications = pattern.get("applications_involved", [])
        
        if any("email" in app.lower() or "outlook" in app.lower() for app in applications):
            base_requirements.extend([
                "imaplib3>=0.9.0",
                "email-validator>=1.2.0"
            ])
        
        if any("excel" in app.lower() or "spreadsheet" in app.lower() for app in applications):
            base_requirements.extend([
                "openpyxl>=3.0.9",
                "pandas>=1.4.0"
            ])
        
        if any("pdf" in app.lower() for app in applications):
            base_requirements.extend([
                "PyPDF2>=2.10.0",
                "pdfplumber>=0.7.0"
            ])
        
        if any("quickbooks" in app.lower() for app in applications):
            base_requirements.append("quickbooks-online>=0.1.0")
        
        if any("salesforce" in app.lower() for app in applications):
            base_requirements.append("simple-salesforce>=1.11.0")
        
        # Remove duplicates and sort
        requirements = sorted(list(set(base_requirements)))
        
        return "\n".join(requirements)
    
    def generate_bot(self, pattern: Dict[str, Any], bot_name: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate a complete automation bot from a workflow pattern.
        
        Args:
            pattern: Detected workflow pattern
            bot_name: Optional custom name for the bot
            
        Returns:
            Dict with generation results and file paths
        """
        
        if not bot_name:
            bot_name = re.sub(r'[^a-zA-Z0-9_]', '_', pattern.get("pattern_name", "automation_bot")).lower()
        
        print(f"ğŸ¤– Generating bot: {bot_name}")
        print(f"ğŸ“‹ Pattern: {pattern.get('pattern_name', 'Unknown')}")
        
        try:
            # Create generation prompt
            prompt = self._create_generation_prompt(pattern)
            
            # Call Claude API
            print("ğŸŒ Calling Claude API for bot generation...")
            response = self.client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=4000,
                messages=[{"role": "user", "content": prompt}]
            )
            
            response_text = response.content[0].text
            
            # Extract code components
            python_code, config_json, requirements = self._extract_code_from_response(response_text)
            
            # Create fallback files if extraction failed
            if not config_json:
                config_json = self._create_default_config(pattern)
            
            if not requirements:
                requirements = self._create_requirements_file(pattern)
            
            # Create bot directory
            bot_dir = self.bots_dir / bot_name
            bot_dir.mkdir(exist_ok=True)
            
            # Save files
            files_created = {}
            
            # Save Python script
            bot_file = bot_dir / f"{bot_name}.py"
            with open(bot_file, 'w') as f:
                f.write(python_code)
            files_created['bot_script'] = str(bot_file)
            
            # Save config file
            config_file = bot_dir / "config.json"
            with open(config_file, 'w') as f:
                f.write(config_json)
            files_created['config_file'] = str(config_file)
            
            # Save requirements
            req_file = bot_dir / "requirements.txt"
            with open(req_file, 'w') as f:
                f.write(requirements)
            files_created['requirements_file'] = str(req_file)
            
            # Save pattern info
            pattern_file = bot_dir / "pattern_info.json"
            with open(pattern_file, 'w') as f:
                json.dump(pattern, f, indent=2)
            files_created['pattern_file'] = str(pattern_file)
            
            # Save raw Claude response for debugging
            response_file = bot_dir / "generation_log.txt"
            with open(response_file, 'w') as f:
                f.write(f"Generated: {datetime.now().isoformat()}\n")
                f.write(f"Pattern: {pattern.get('pattern_name', 'Unknown')}\n")
                f.write("=" * 60 + "\n")
                f.write(response_text)
            files_created['generation_log'] = str(response_file)
            
            # Create README
            readme_content = f"""# {pattern.get('pattern_name', 'Automation Bot')}

**Generated by Workflow Observer AI**
**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overview
{pattern.get('business_value', 'Automates detected workflow pattern')}

## Workflow Steps
{chr(10).join(f"{i+1}. {step}" for i, step in enumerate(pattern.get('workflow_steps', [])))}

## Applications Involved
{', '.join(pattern.get('applications_involved', []))}

## Estimated Time Savings
{pattern.get('time_savings_estimate', 'Unknown')}

## Setup Instructions

1. **Install Dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

2. **Configure Settings:**
   - Edit `config.json` with your credentials and settings
   - Update file paths and application-specific settings

3. **Run the Bot:**
   ```bash
   python {bot_name}.py
   ```

## Configuration
Edit `config.json` to customize:
- Credentials for applications
- File paths and directories
- Automation timing and retry settings
- Notification preferences

## Automation Approach
**Automation Potential:** {pattern.get('automation_potential', 'N/A')}/10
**Implementation:** {pattern.get('implementation_approach', 'Custom automation script')}

## Notes
- Test the bot thoroughly before production use
- Monitor the first few runs to ensure accuracy
- Keep credentials secure and use environment variables when possible
"""
            
            readme_file = bot_dir / "README.md"
            with open(readme_file, 'w') as f:
                f.write(readme_content)
            files_created['readme_file'] = str(readme_file)
            
            # Store bot info
            bot_info = {
                "id": bot_name,
                "pattern_name": pattern.get("pattern_name", "Unknown"),
                "pattern_type": pattern.get("pattern_type", "unknown"),
                "automation_potential": pattern.get("automation_potential", 0),
                "time_savings": pattern.get("time_savings_estimate", "Unknown"),
                "applications": pattern.get("applications_involved", []),
                "created_at": datetime.now().isoformat(),
                "directory": str(bot_dir),
                "files": files_created,
                "status": "generated",
                "implementation_approach": pattern.get("implementation_approach", ""),
                "business_value": pattern.get("business_value", "")
            }
            
            self.generated_bots[bot_name] = bot_info
            self.total_generations += 1
            
            print(f"âœ… Bot generated successfully!")
            print(f"ğŸ“ Location: {bot_dir}")
            print(f"ğŸ”§ Files created: {len(files_created)}")
            
            return bot_info
            
        except Exception as e:
            error_info = {
                "id": bot_name,
                "pattern_name": pattern.get("pattern_name", "Unknown"),
                "status": "failed",
                "error": str(e),
                "created_at": datetime.now().isoformat()
            }
            
            print(f"âŒ Bot generation failed: {e}")
            return error_info
    
    def generate_multiple_bots(self, patterns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Generate automation bots for multiple patterns.
        
        Args:
            patterns: List of detected workflow patterns
            
        Returns:
            List of generation results
        """
        
        print(f"ğŸ¤– Generating {len(patterns)} automation bots...")
        
        results = []
        for i, pattern in enumerate(patterns, 1):
            print(f"\nğŸ”„ Generating bot {i}/{len(patterns)}")
            
            try:
                result = self.generate_bot(pattern)
                results.append(result)
                
                # Brief pause between generations
                time.sleep(2)
                
            except Exception as e:
                print(f"âŒ Failed to generate bot {i}: {e}")
                continue
        
        print(f"\nâœ… Bot generation complete!")
        print(f"ğŸ“Š Successfully generated: {len([r for r in results if r.get('status') == 'generated'])}/{len(patterns)} bots")
        
        return results
    
    def get_generated_bots(self) -> Dict[str, Any]:
        """Get information about all generated bots."""
        return {
            "total_bots": len(self.generated_bots),
            "bots": self.generated_bots,
            "generation_stats": {
                "total_generations": self.total_generations,
                "successful": len([b for b in self.generated_bots.values() if b.get("status") == "generated"]),
                "failed": len([b for b in self.generated_bots.values() if b.get("status") == "failed"])
            }
        }
    
    def save_generation_summary(self, output_file: str = "bot_generation_summary.json"):
        """Save a summary of all generated bots."""
        summary = self.get_generated_bots()
        
        with open(output_file, 'w') as f:
            json.dump(summary, f, indent=2)
        
        print(f"ğŸ’¾ Generation summary saved to: {output_file}")


def main():
    """Test function for the bot generator."""
    
    print("ğŸ¤– Bot Code Generator Test")
    print("=" * 60)
    
    # Check for API key
    if not os.getenv('ANTHROPIC_API_KEY'):
        print("âŒ ANTHROPIC_API_KEY environment variable not set")
        return
    
    # Initialize generator
    try:
        generator = BotCodeGenerator()
    except Exception as e:
        print(f"âŒ Failed to initialize generator: {e}")
        return
    
    # Load detected patterns if available
    patterns_file = "detected_patterns.json"
    if Path(patterns_file).exists():
        print(f"ğŸ“‹ Loading patterns from {patterns_file}")
        
        with open(patterns_file, 'r') as f:
            patterns = json.load(f)
        
        if patterns and len(patterns) > 0:
            print(f"ğŸ” Found {len(patterns)} detected patterns")
            
            # Ask which patterns to generate bots for
            print("\nAvailable patterns:")
            for i, pattern in enumerate(patterns):
                name = pattern.get('pattern_name', f'Pattern {i+1}')
                potential = pattern.get('automation_potential', 'N/A')
                print(f"  {i+1}. {name} (Automation Potential: {potential})")
            
            choice = input(f"\nGenerate bots for which patterns? (1-{len(patterns)}, 'all', or comma-separated): ").strip()
            
            if choice.lower() == 'all':
                selected_patterns = patterns
            else:
                try:
                    if ',' in choice:
                        indices = [int(x.strip()) - 1 for x in choice.split(',')]
                    else:
                        indices = [int(choice) - 1]
                    
                    selected_patterns = [patterns[i] for i in indices if 0 <= i < len(patterns)]
                except (ValueError, IndexError):
                    print("âŒ Invalid selection")
                    return
            
            # Generate bots
            print(f"\nğŸš€ Generating bots for {len(selected_patterns)} patterns...")
            results = generator.generate_multiple_bots(selected_patterns)
            
            # Save summary
            generator.save_generation_summary()
            
            print(f"\nğŸ‰ Bot generation complete!")
            print(f"ğŸ“ Check the 'generated_bots/' directory for your automation scripts")
            
        else:
            print("âŒ No patterns found in the file")
    else:
        print(f"âŒ Patterns file not found: {patterns_file}")
        print("ğŸ’¡ Run pattern analysis first to detect workflow patterns")


if __name__ == "__main__":
    main()